@page "/TestGen"
@using Client.Services
@using Shared.DTO
@using System.Text.RegularExpressions
<h3>MapGenerator</h3>
@inject MapService MapS
@inject IJSRuntime Js
@inject ILocalStorageService LocalStorageService

<button type="submit" class="btn btn-primary" onclick="@CreateSetTrue">Stworefres</button>
<button type="submit" class="btn btn-primary" onclick="@CreateSetTrue2">xda </button>
<table class="table">
	<thead>
		<tr>
			<th>Nazwa zbiory</th>
			<th>Zobacz</th>
		</tr>
	</thead>
	<tbody>
		@foreach (var ts in MapS.TileSetDtos)
		{
			<tr>
				<td>
					<div>@ts.Name</div> </td>
				<td>
					<button class="btn btn-primary"
					        @onclick="(() => SetCurrSet(ts))">
						<i class="oi oi-pencil"></i>
					</button>
				</td>
			</tr>
		}
	</tbody>
</table>

@if (CurrSetDto.Id != 0)
{
	<EditForm Model="Map" OnSubmit="PrepareMap">
		<div>
			<label for="name">Nazwa</label>
			<InputText id="name" @bind-Value="Map.Name" class="from-control" />
		</div>
		<div>
			<label for="N">Wysokość</label>
			<InputNumber id="N" @bind-Value="Map.N" class="from-control" />
		</div>
		<div>
			<label for="M">Szerkość</label>
			<InputNumber id="M" @bind-Value="Map.M" class="from-control" />
		</div>
		
		<button type="submit" class="btn btn-primary">Potwierdz</button>
	</EditForm>
	
	
	@if (ok )
	{

		@for (int i = 0; i < Map.N; i++)
		{
			<div class="image-grid">
				<div class="row">
              
					@for (int j = 0; j < Map.M; j++)
					{
						<div class="col">
							@{
								var i1 = i;
								var j1 = j;
							}
							<img id="imgId_@i+@j"  @onclick="@(()=>SetImage(i1,j1))" alt="" src=""/>
						</div>
					}
				</div>
			</div>
		}
		<button type="submit" class="btn btn-primary" onclick="@GenerateMap">Wygeneruj mape</button>
		<table class="table">
			<thead>
			<tr>
				<th>Image</th>
				<th>waga</th>
			</tr>
			</thead>
			<tbody>
			@foreach (var t in Map.TileWeightDtos)
			{
				<tr>
					<td> <img class="fix-size" src="@MapS.TilesUrl[t.TileId].Url" @onclick="@(()=> ChosenTile(t.TileId))" alt=""/> </td>
					<td>
						<div> @t.Weight</div>
						
					</td>
				</tr>
			}
			</tbody>
		</table>
      
	}
}

@code {
	private readonly string tileKey = "tile_";
    protected override async void OnInitialized()
    {
	   
	    await MapS.TileSets2();
	    this.StateHasChanged();
    }
    private TileSetDto CurrSetDto = new TileSetDto();

    private async Task CreateSetTrue()
    {
	    await MapS.TileSets2();
    }
    private async Task CreateSetTrue2()
    {
	    CurrSetDto.Id = 1;
    }
    private async Task SetCurrSet(TileSetDto tileSetDto)
    {
	    
	    Map = await MapS.PrepareNewMap(tileSetDto.Id);
	    
	    await MapS.GetBaseTile();
	    await MapS.GetTilesToHash(Map.TileSetId);
	    CurrSetDto = tileSetDto;
    }

    private GeneratedMapDto Map = new GeneratedMapDto();
    bool ok = false;
    
    protected async Task PrepareMap()
    {
	    string  url = await LocalStorageService.GetItemAsStringAsync(tileKey + 1);
		url = await LocalStorageService.GetItemAsync<string>(tileKey + 1);
	    ok = true;
	    Map.SetTileDtos = new List<SetTileDto>();
	    this.StateHasChanged();
	    for (int i = 0; i < Map.N;i++)
	    {
		    for (int j = 0; j < Map.M; j++)
		    {
			    await Js.InvokeVoidAsync("setImageUrl","imgId_"+i+"+"+j , url ,0);
		    }
	    }
		
    }

    private long IdToset = 0;

    private async Task SetImage(int i, int j)
    {
	    if (IdToset != 0)
	    {
		    await Js.InvokeVoidAsync("setImageUrl", "imgId_" + i + "+" + j, MapS.TilesUrl[IdToset].Url, 0);
		    Map.SetTileDtos.Add(new SetTileDto()
		    {
			    N = i, M = j, TileId = IdToset
		    });
	    }
    }



    private void ChosenTile(long id)
    {
	    IdToset = id;
    }
    
    
    private List<TileParam> TilesTypes = new List<TileParam>();
    private List<long> TilesIds = new List<long>();
	private Tilep[][] mapOfTile;
	private PriorityQueue<int[], double> q = new PriorityQueue<int[], double>();
	private List<int> allPossibilities = new List<int>();
 	private Random rnd = new Random();
    private int toReaload;
    private int currReaload;
    int[] curr;
	private async Task GenerateMap()
	{
		
		mapOfTile = new Tilep[Map.N][];
		for (int i = 0; i < Map.N; i++)
		{
			mapOfTile[i] = new Tilep[Map.M];
		}
		TilesTypes.Clear();
		TilesIds.Clear();
		int seed = (int)DateTime.Now.Ticks & 0x0000FFFF;
		rnd = new Random(seed);
		toReaload = Map.N * Map.M / 100;
		currReaload = 0;
		foreach (var tw in Map.TileWeightDtos)
		{
			if (tw.Weight != 0)
			{
				TilesTypes.Add( new TileParam()
				{
					pola = new string[] { MapS.TilesUrl[tw.TileId].P0,MapS.TilesUrl[tw.TileId].P1,MapS.TilesUrl[tw.TileId].P2,MapS.TilesUrl[tw.TileId].P3 },
					weight = tw.Weight
				} );
				TilesIds.Add(tw.TileId);
			
			}
			
		} 
		allPossibilities = new List<int>();
		for (int i = 0; i < TilesTypes.Count(); i++)
		{
			allPossibilities.Add(i);
		}
		
		for (int i = 0; i < Map.N; i++)
		{
			for (int j = 0; j < Map.M; j++)
			{
				mapOfTile[i][j] = new Tilep();
			}
		}
		q.Clear();
		foreach (var st in Map.SetTileDtos)
		{
			mapOfTile[st.N][st.M].Type = st.TileId;
			EvaluateBeginning(st.N,st.M);
		}

		if (q.Count == 0)
		{
			q.Enqueue([0,0],1);
			mapOfTile[0][0].Possibilities = allPossibilities;
			Entropy(0, 0);
		}
		
		
		while (q.Count > 0)
		{
			curr = q.Dequeue();
			
			Console.WriteLine("kolejka :" + curr[0]+" "+curr[1]);
			 await Evaluate(curr[0],curr[1]);

		}
	
		
	}

	private void Reduce(string by, int n, int m, int direction)
	{
		if (mapOfTile[n][m].Type != -1) return ;
		List<int> correct = new List<int>();
		int start = direction;
		if (mapOfTile[n][m].Possibilities == null) mapOfTile[n][m].Possibilities = allPossibilities;
		
		foreach (var t in mapOfTile[n][m].Possibilities)
		{
			if (RevCompere(TilesTypes[t].pola[start],by))
			{
				correct.Add(t);
			}

		}

		mapOfTile[n][m].Possibilities = correct;
		Console.WriteLine("do kolejki "+n+" " +m+" "+   Entropy(n,m) );
		q.Enqueue([n,m], Entropy(n,m));
	}

	private bool RevCompere(string s1, string s2)
	{
		if (s1.Length != s2.Length) return false;
		int n = s1.Length -1;
		foreach (var c in s2)
		{
			if (c != s1[n--]) return false;
		}

		return true;

	}
	private double Entropy(int n, int m)
	{
		mapOfTile[n][m].WeightSum = 0;
		foreach (var t in mapOfTile[n][m].Possibilities)
		{
			mapOfTile[n][m].WeightSum += TilesTypes[t].weight;
		}
		double sum = mapOfTile[n][m].WeightSum;

		double entropy = 0;
		foreach (var t in mapOfTile[n][m].Possibilities)
		{
			entropy += TilesTypes[t].weight / sum * double.Log2(sum / TilesTypes[t].weight);
		}

		return entropy;

	}
	private async Task Evaluate(int n, int m )
	{
		Console.WriteLine("evaliate "+n+" "+m + " "+mapOfTile[n][m].WeightSum);
		if (mapOfTile[n][m].Type != -1) return;
	
		if (mapOfTile[n][m].Possibilities.Count() == 0) return;
		long   tileId;
		
		int tile = rnd.Next(mapOfTile[n][m].WeightSum);
		

		foreach (var t in  mapOfTile[n][m].Possibilities)
		{
			tile -= TilesTypes[t].weight;
			if (tile < 0)
			{
				tile = t;
				break;
			}
		}
		
		tileId = TilesIds[tile];
		mapOfTile[n][m].Type = tileId;
		await Js.InvokeVoidAsync("setImageUrl", "imgId_" + n + "+" + m, MapS.TilesUrl[tileId].Url, 0);
		currReaload++;
		if (currReaload <= toReaload)
		{
			currReaload = 0;
			await Task.Delay(1);
		}
		
		
		if (n > 0)
		{
			Reduce( MapS.TilesUrl[tileId].P1,n-1,m,3);
		}
		if (m > 0)
		{
			Reduce( MapS.TilesUrl[tileId].P2,n,m-1,0);
		}
		if (n < Map.N -1)
		{
			Reduce( MapS.TilesUrl[tileId].P3,n+1,m,1);
		}
		if (m < Map.M-1)
		{
			Reduce( MapS.TilesUrl[tileId].P0,n,m+1,2);
		}
	}
	private void  EvaluateBeginning(int n, int m )
	{
		
		long   tileId =mapOfTile[n][m].Type;
		
		if (n > 0)
		{
			Reduce( MapS.TilesUrl[tileId].P1,n-1,m,3);
		}
		if (m > 0)
		{
			Reduce( MapS.TilesUrl[tileId].P2,n,m-1,0);
		}
		if (n < Map.N -1)
		{
			Reduce( MapS.TilesUrl[tileId].P3,n+1,m,1);
		}
		if (m < Map.M-1)
		{
			Reduce( MapS.TilesUrl[tileId].P0,n,m+1,2);
		}
	}
}