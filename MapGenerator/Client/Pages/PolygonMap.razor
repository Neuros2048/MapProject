@page "/PolygonMap"
@using Client.SubPages
@using System.Numerics
@using System.Drawing
@using Client.Logic
@using Client.Services
@inject PolygonMapService Pms
<h3>PolygonMap</h3>
<button type="submit" class="btn btn-primary" onclick="@GenMap">Niech isę stanie </button>
<div  class="graphicFiled">
<CanvasPolygon @ref="_canvasPolygon" OnMouseClick="OnMouseClick"></CanvasPolygon></div>
<button type="submit" class="btn btn-primary" onclick="@Clear">Wyczysc </button>

@code {
    private CanvasPolygon _canvasPolygon = null!;

    private async void OnMouseClick(CanvasPolygon.Pos pos)
    {
        await _canvasPolygon.DrawPoint(pos.X, pos.Y);
    }
  
    
    double[][] output;
    private async void GenMap()
    {
        Random rnd;
        int seed = (int)DateTime.Now.Ticks & 0x0000FFFF;
        Console.WriteLine(seed);
        rnd = new Random(seed);
        int wight = _canvasPolygon.GetWight();
        int height = _canvasPolygon.GetHeight();
  
        int pn = 400;
        await _canvasPolygon.ClearMap();
       
        List<PolygonMapService.Point> points = new List<PolygonMapService.Point>();
        for (int i = 0; i < pn; i++)
        {
            points.Add( new PolygonMapService.Point(rnd.Next(wight), rnd.Next(height)));
            //await _canvasPolygon.DrawPoint(rnd.Next(wight), rnd.Next(height));
        }
        //
        Noise noise = new Noise();
       
        noise.PerlinNoise2D(800,800,432,4,1.0,out output);
        
        Console.WriteLine($"{output[0][200]} OK");


        

        int[][] nois = new int[wight][];
        for (int i = 0; i < wight; i++)
        {
            nois[i] = new int[height];
        }
        //perlinNoise = new Noise(42); // Seed can be any integer
      
        
        //noise = perlinNoise.GeneratePerlinNoise(wight, height, 10);
        
        
        
        List<Poly2.Center> centers = new List<Poly2.Center>();
        //        points.Select(x => new Poly2.Point((int)x.X, (int)x.Y)).ToList()
        points.ForEach(p=> centers.Add(new Poly2.Center(new Poly2.Point((int)p.X*100, (int)p.Y*100),800*100,0,800*100,0)));
        
       
        centers = await drawCentres(centers);
        foreach (var pol in centers)
        {
            pol.P.X = 0;
            pol.P.Y = 0;
            var a = pol.E;
            var next = a;
            int ile = 0;
            do
            {
                ile++;
                pol.P.X += next.Point.X;
                pol.P.Y += next.Point.Y;
                next = next.Next;
            } while (a != next);

            pol.P.X /= ile;
            pol.P.Y /= ile;

        }

        for (int i = 0; i < centers.Count; i++)
        {
            centers[i] = new Poly2.Center(centers[i].P, 800*100, 0, 800*100, 0);
        }

        await Task.Delay(1);
        await drawCentres(centers);

        

    }

    private async Task<List<Poly2.Center>> drawCentres(List<Poly2.Center> centers)
    {
        
        var oper = new Poly2(800*100,0,800*100,0);
        centers = oper.Solve(centers);
        await _canvasPolygon.ClearMap();
        int j =0;
        
        foreach (var pol in centers)
        {
            await _canvasPolygon.ChangeColorLine(j++);
            
            var a = pol.E;
            var next = a;
            var px = pol.P.X / 100;
            var py = pol.P.Y / 100;
        
            if (output[ px][py] > 0.7)
            {
                await _canvasPolygon.ChangeColorFill(CanvasPolygon.LandTypes.Gory);
            }
            else if (output[ px][py]  > 0.4)
            {
                await _canvasPolygon.ChangeColorFill(CanvasPolygon.LandTypes.Las);
            }
            else
            {
                await _canvasPolygon.ChangeColorFill(CanvasPolygon.LandTypes.Woda);
            }
            await _canvasPolygon.DrawPoint((int)pol.P.X/100,(int) pol.P.Y/100);
            await _canvasPolygon.DrawShape(pol,100);
            

            await Task.Delay(1);
        }

        return centers;
    }
    
    private async void Clear()
    {
        await _canvasPolygon.ClearMap();
    }

   

    
    
    
    
    
    
    
}