@page "/SavedMaps"
@using Client.Services
@using Shared.DTO

<h3>MapGenerator</h3>
@inject MapService MapS
@inject IJSRuntime Js
@inject ILocalStorageService LocalStorageService


<table class="table">
	<thead>
		<tr>
			<th>Nazwa zbiory</th>
			<th>Zobacz</th>
		</tr>
	</thead>
	<tbody>
		@foreach (var ts in _tileSetDtos)
		{
			<tr>
				<td>
					<div>@ts.Name</div> </td>
				<td>
					<button class="btn btn-primary"
					        @onclick="(() => SetCurrSet(ts))">
						<i class="oi oi-pencil"></i>
					</button>
				</td>
			</tr>
		}
	</tbody>
</table>

@if (CurrSetDto.Id != 0)
{
	<table class="table">
		<thead>
		<tr>
			<th>Nazwa Mapy</th>
			<th>Zobacz</th>
		</tr>
		</thead>
		<tbody>
		@foreach (var tm in _generatedMap)
		{
			<tr>
				<td>
					<div>@tm.Name</div> </td>
				<td>
					<button class="btn btn-primary"
					        @onclick="(() => MakeMap(tm))">
						<i class="oi oi-pencil"></i>
					</button>
				</td>
			</tr>
		}
		</tbody>
	</table>
	
	
	@if (ok )
	{

		@for (int i = 0; i < Map.N; i++)
		{
			<div class="image-grid">
				<div class="row">
              
					@for (int j = 0; j < Map.M; j++)
					{
						<div class="col">
							@{
								var i1 = i;
								var j1 = j;
							}
							<img id="imgId_@i+@j"   alt="" src=""/>
						</div>
					}
				</div>
			</div>
		}
		
	}
}

@code {
	private readonly string tileKey = "tile_";
	private List<TileSetDto> _tileSetDtos = new List<TileSetDto>();
	private List<GeneratedMapDto> _generatedMap = new List<GeneratedMapDto>();
    protected override async void OnInitialized()
    {
	   
	    _tileSetDtos = await MapS.TileSets();
	    this.StateHasChanged();
    }
    private TileSetDto CurrSetDto = new TileSetDto();
    
    private async Task SetCurrSet(TileSetDto tileSetDto)
    {
	    
	    await MapS.GetBaseTile();
	    await MapS.GetTilesToHash(tileSetDto.Id);
	    _generatedMap = await MapS.GetMaps(tileSetDto.Id);
	    CurrSetDto = tileSetDto;
    }
	
    private GeneratedMapDto Map = new GeneratedMapDto();
    bool ok = false;

    private async Task MakeMap(GeneratedMapDto generatedMapDto)
    {
	    ok = false;
	    Map = await MapS.GetMap(generatedMapDto.Id);
	    ok = true;
	    this.StateHasChanged();
	    await PrepareMap();
	    await SetSettedTiles();
	    await GenerateMap();
    }

    private async Task PrepareMap()
    {
	    string  url = await LocalStorageService.GetItemAsStringAsync(tileKey + 1);
		url = await LocalStorageService.GetItemAsync<string>(tileKey + 1);
	    ok = true;
	    this.StateHasChanged();
	    for (int i = 0; i < Map.N;i++)
	    {
		    for (int j = 0; j < Map.M; j++)
		    {
			    await Js.InvokeVoidAsync("setImageUrl","imgId_"+i+"+"+j , url ,0);
		    }
	    }
		
    }

    private async Task SetSettedTiles()
    {
	    foreach (var st in Map.SetTileDtos)
	    {
		    await Js.InvokeVoidAsync("setImageUrl", "imgId_" + st.N + "+" + st.M, MapS.TilesUrl[st.TileId].Url, 0);
	    }
    }
   


    
    private List<TileParam> TilesTypes = new List<TileParam>();
    private List<long> TilesIds = new List<long>();
	private Tilep[][] mapOfTile;
	private PriorityQueue<int[], double> q = new PriorityQueue<int[], double>();
	private List<int> allPossibilities = new List<int>();
 	private Random rnd = new Random();
    private int toReaload;
    private int currReaload;
    int[] curr;
	private async Task GenerateMap()
	{
		
		mapOfTile = new Tilep[Map.N][];
		for (int i = 0; i < Map.N; i++)
		{
			mapOfTile[i] = new Tilep[Map.M];
		}
		TilesTypes.Clear();
		TilesIds.Clear();
		rnd = new Random(Map.seed);
		toReaload = Map.N * Map.M / 100;
		currReaload = 0;
		foreach (var tw in Map.TileWeightDtos)
		{
			if (tw.Weight != 0)
			{
				TilesTypes.Add( new TileParam()
				{
					pola = new string[] { MapS.TilesUrl[tw.TileId].P0,MapS.TilesUrl[tw.TileId].P1,MapS.TilesUrl[tw.TileId].P2,MapS.TilesUrl[tw.TileId].P3 },
					weight = tw.Weight
				} );
				TilesIds.Add(tw.TileId);
			
			}
			
		} 
		allPossibilities = new List<int>();
		for (int i = 0; i < TilesTypes.Count(); i++)
		{
			allPossibilities.Add(i);
		}
		
		for (int i = 0; i < Map.N; i++)
		{
			for (int j = 0; j < Map.M; j++)
			{
				mapOfTile[i][j] = new Tilep();
			}
		}
		q.Clear();
		foreach (var st in Map.SetTileDtos)
		{
			mapOfTile[st.N][st.M].Type = st.TileId;
			EvaluateBeginning(st.N,st.M);
		}

		if (q.Count == 0)
		{
			q.Enqueue([0,0],1);
			mapOfTile[0][0].Possibilities = allPossibilities;
			Entropy(0, 0);
		}
		
		
		while (q.Count > 0)
		{
			curr = q.Dequeue();
			
			Console.WriteLine("kolejka :" + curr[0]+" "+curr[1]);
			 await Evaluate(curr[0],curr[1]);

		}
	
		
	}

	private void Reduce(string by, int n, int m, int direction)
	{
		if (mapOfTile[n][m].Type != -1) return ;
		List<int> correct = new List<int>();
		int start = direction;
		if (mapOfTile[n][m].Possibilities == null) mapOfTile[n][m].Possibilities = allPossibilities;
		
		foreach (var t in mapOfTile[n][m].Possibilities)
		{
			if (RevCompere(TilesTypes[t].pola[start],by))
			{
				correct.Add(t);
			}

		}

		mapOfTile[n][m].Possibilities = correct;
		Console.WriteLine("do kolejki "+n+" " +m+" "+   Entropy(n,m) );
		q.Enqueue([n,m], Entropy(n,m));
	}

	private bool RevCompere(string s1, string s2)
	{
		if (s1.Length != s2.Length) return false;
		int n = s1.Length -1;
		foreach (var c in s2)
		{
			if (c != s1[n--]) return false;
		}

		return true;

	}
	private double Entropy(int n, int m)
	{
		mapOfTile[n][m].WeightSum = 0;
		foreach (var t in mapOfTile[n][m].Possibilities)
		{
			mapOfTile[n][m].WeightSum += TilesTypes[t].weight;
		}
		double sum = mapOfTile[n][m].WeightSum;

		double entropy = 0;
		foreach (var t in mapOfTile[n][m].Possibilities)
		{
			entropy += TilesTypes[t].weight / sum * double.Log2(sum / TilesTypes[t].weight);
		}

		return entropy;

	}
	private async Task Evaluate(int n, int m )
	{
		Console.WriteLine("evaliate "+n+" "+m + " "+mapOfTile[n][m].WeightSum);
		if (mapOfTile[n][m].Type != -1) return;
	
		if (mapOfTile[n][m].Possibilities.Count() == 0) return;
		long   tileId;
		
		int tile = rnd.Next(mapOfTile[n][m].WeightSum);
		

		foreach (var t in  mapOfTile[n][m].Possibilities)
		{
			tile -= TilesTypes[t].weight;
			if (tile < 0)
			{
				tile = t;
				break;
			}
		}
		
		tileId = TilesIds[tile];
		mapOfTile[n][m].Type = tileId;
		await Js.InvokeVoidAsync("setImageUrl", "imgId_" + n + "+" + m, MapS.TilesUrl[tileId].Url, 0);
		currReaload++;
		if (currReaload <= toReaload)
		{
			currReaload = 0;
			await Task.Delay(1);
		}
		
		
		if (n > 0)
		{
			Reduce( MapS.TilesUrl[tileId].P1,n-1,m,3);
		}
		if (m > 0)
		{
			Reduce( MapS.TilesUrl[tileId].P2,n,m-1,0);
		}
		if (n < Map.N -1)
		{
			Reduce( MapS.TilesUrl[tileId].P3,n+1,m,1);
		}
		if (m < Map.M-1)
		{
			Reduce( MapS.TilesUrl[tileId].P0,n,m+1,2);
		}
	}
	private void  EvaluateBeginning(int n, int m )
	{
		
		long   tileId =mapOfTile[n][m].Type;
		
		if (n > 0)
		{
			Reduce( MapS.TilesUrl[tileId].P1,n-1,m,3);
		}
		if (m > 0)
		{
			Reduce( MapS.TilesUrl[tileId].P2,n,m-1,0);
		}
		if (n < Map.N -1)
		{
			Reduce( MapS.TilesUrl[tileId].P3,n+1,m,1);
		}
		if (m < Map.M-1)
		{
			Reduce( MapS.TilesUrl[tileId].P0,n,m+1,2);
		}
	}

}